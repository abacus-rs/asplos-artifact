diff --git a/drivers/usb/xhcid/src/driver_interface.rs b/drivers/usb/xhcid/src/driver_interface.rs
index 3268aa3d..035e93da 100644
--- a/drivers/usb/xhcid/src/driver_interface.rs
+++ b/drivers/usb/xhcid/src/driver_interface.rs
@@ -157,7 +157,8 @@ impl EndpDesc {
         self.ssc.is_some()
     }
     pub fn is_superspeedplus(&self) -> bool {
-        self.sspc.is_some()
+        log::warn!("TODO: is_superspeedplus not implemented, defaulting to false");
+        false
     }
     fn interrupt_usage_bits(&self) -> u8 {
         assert!(self.is_interrupt());
@@ -814,7 +815,7 @@ impl XhciEndpHandle {
     pub fn transfer_nodata(&mut self) -> result::Result<PortTransferStatus, XhciClientHandleError> {
         self.generic_transfer(XhciEndpCtlDirection::NoData, |_| Ok(0), 0)
     }
-    fn transfer_stream(&mut self, total_len: u32) -> TransferStream<'_> {
+    fn transfer_stream(&mut self, total_len: u32) -> TransferStream {
         TransferStream {
             bytes_to_transfer: total_len,
             bytes_transferred: 0,
@@ -822,12 +823,12 @@ impl XhciEndpHandle {
             endp_handle: self,
         }
     }
-    pub fn transfer_write_stream(&mut self, total_len: u32) -> TransferWriteStream<'_> {
+    pub fn transfer_write_stream(&mut self, total_len: u32) -> TransferWriteStream {
         TransferWriteStream {
             inner: self.transfer_stream(total_len),
         }
     }
-    pub fn transfer_read_stream(&mut self, total_len: u32) -> TransferReadStream<'_> {
+    pub fn transfer_read_stream(&mut self, total_len: u32) -> TransferReadStream {
         TransferReadStream {
             inner: self.transfer_stream(total_len),
         }
diff --git a/drivers/usb/xhcid/src/main.rs b/drivers/usb/xhcid/src/main.rs
index 613bd1c7..800614e2 100644
--- a/drivers/usb/xhcid/src/main.rs
+++ b/drivers/usb/xhcid/src/main.rs
@@ -22,20 +22,20 @@
 //! - USB2  - [Universal Serial Bus Specification](https://www.usb.org/document-library/usb-20-specification)
 //! - USB32 - [Universal Serial Bus 3.2 Specification Revision 1.1](https://usb.org/document-library/usb-32-revision-11-june-2022)
 //!
-#![allow(warnings)]
-
 #[macro_use]
 extern crate bitflags;
 
 use std::fs::File;
-use std::sync::Arc;
+use std::ptr::NonNull;
+use std::sync::{Arc, Mutex};
 
-use pcid_interface::irq_helpers::read_bsp_apic_id;
 #[cfg(target_arch = "x86_64")]
-use pcid_interface::irq_helpers::{
-    allocate_first_msi_interrupt_on_bsp, allocate_single_interrupt_vector_for_msi,
+use pcid_interface::irq_helpers::allocate_single_interrupt_vector_for_msi;
+use pcid_interface::irq_helpers::read_bsp_apic_id;
+use pcid_interface::msi::MsixTableEntry;
+use pcid_interface::{
+    MsiSetFeatureInfo, PciFeature, PciFeatureInfo, PciFunctionHandle, SetFeatureInfo,
 };
-use pcid_interface::{PciFeature, PciFeatureInfo, PciFunctionHandle};
 
 use redox_scheme::{RequestKind, SignalBehavior, Socket};
 
@@ -50,7 +50,10 @@ mod usb;
 mod xhci;
 
 #[cfg(target_arch = "x86_64")]
-fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, InterruptMethod) {
+fn get_int_method(
+    pcid_handle: &mut PciFunctionHandle,
+    bar0_address: usize,
+) -> (Option<File>, InterruptMethod) {
     let pci_config = pcid_handle.config();
 
     let all_pci_features = pcid_handle.fetch_all_features();
@@ -59,12 +62,46 @@ fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, Interru
     let has_msi = all_pci_features.iter().any(|feature| feature.is_msi());
     let has_msix = all_pci_features.iter().any(|feature| feature.is_msix());
 
-    if has_msix {
+    if has_msi && !has_msix {
+        let mut capability = match pcid_handle.feature_info(PciFeature::Msi) {
+            PciFeatureInfo::Msi(s) => s,
+            PciFeatureInfo::MsiX(_) => panic!(),
+        };
+        // TODO: Allow allocation of up to 32 vectors.
+
+        // TODO: Find a way to abstract this away, potantially as a helper module for
+        // pcid_interface, so that this can be shared between nvmed, xhcid, ixgebd, etc..
+
+        let destination_id = read_bsp_apic_id().expect("xhcid: failed to read BSP apic id");
+        let (msg_addr_and_data, interrupt_handle) =
+            allocate_single_interrupt_vector_for_msi(destination_id);
+
+        let set_feature_info = MsiSetFeatureInfo {
+            multi_message_enable: Some(0),
+            message_address_and_data: Some(msg_addr_and_data),
+            mask_bits: None,
+        };
+        pcid_handle.set_feature_info(SetFeatureInfo::Msi(set_feature_info));
+
+        pcid_handle.enable_feature(PciFeature::Msi);
+        log::debug!("Enabled MSI");
+
+        (Some(interrupt_handle), InterruptMethod::Msi)
+    } else if has_msix {
         let msix_info = match pcid_handle.feature_info(PciFeature::MsiX) {
             PciFeatureInfo::Msi(_) => panic!(),
             PciFeatureInfo::MsiX(s) => s,
         };
-        let mut info = unsafe { msix_info.map_and_mask_all(pcid_handle) };
+        msix_info.validate(pci_config.func.bars);
+
+        assert_eq!(msix_info.table_bar, 0);
+        let virt_table_base =
+            (bar0_address + msix_info.table_offset as usize) as *mut MsixTableEntry;
+
+        let mut info = xhci::MappedMsixRegs {
+            virt_table_base: NonNull::new(virt_table_base).unwrap(),
+            info: msix_info,
+        };
 
         // Allocate one msi vector.
 
@@ -72,6 +109,7 @@ fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, Interru
             // primary interrupter
             let k = 0;
 
+            assert_eq!(std::mem::size_of::<MsixTableEntry>(), 16);
             let table_entry_pointer = info.table_entry_pointer(k);
 
             let destination_id = read_bsp_apic_id().expect("xhcid: failed to read BSP apic id");
@@ -80,16 +118,16 @@ fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, Interru
             table_entry_pointer.write_addr_and_data(msg_addr_and_data);
             table_entry_pointer.unmask();
 
-            (Some(interrupt_handle), InterruptMethod::Msi)
+            (
+                Some(interrupt_handle),
+                InterruptMethod::MsiX(Mutex::new(info)),
+            )
         };
 
         pcid_handle.enable_feature(PciFeature::MsiX);
         log::debug!("Enabled MSI-X");
 
         method
-    } else if has_msi {
-        let interrupt_handle = allocate_first_msi_interrupt_on_bsp(pcid_handle);
-        (Some(interrupt_handle), InterruptMethod::Msi)
     } else if let Some(irq) = pci_config.func.legacy_interrupt_line {
         log::debug!("Legacy IRQ {}", irq);
 
@@ -103,7 +141,10 @@ fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, Interru
 
 //TODO: MSI on non-x86_64?
 #[cfg(not(target_arch = "x86_64"))]
-fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, InterruptMethod) {
+fn get_int_method(
+    pcid_handle: &mut PciFunctionHandle,
+    address: usize,
+) -> (Option<File>, InterruptMethod) {
     let pci_config = pcid_handle.config();
 
     if let Some(irq) = pci_config.func.legacy_interrupt_line {
@@ -115,11 +156,12 @@ fn get_int_method(pcid_handle: &mut PciFunctionHandle) -> (Option<File>, Interru
     }
 }
 
-//TODO: cleanup CSZ support
-fn daemon_with_context_size<const N: usize>(
-    daemon: daemon::Daemon,
-    mut pcid_handle: PciFunctionHandle,
-) -> ! {
+fn main() {
+    redox_daemon::Daemon::new(daemon).expect("xhcid: failed to daemonize");
+}
+
+fn daemon(daemon: redox_daemon::Daemon) -> ! {
+    let mut pcid_handle = PciFunctionHandle::connect_default();
     let pci_config = pcid_handle.config();
 
     let mut name = pci_config.func.name();
@@ -129,26 +171,26 @@ fn daemon_with_context_size<const N: usize>(
         "usb",
         "host",
         &name,
-        log::LevelFilter::Warn,
-        common::file_level(),
+        log::LevelFilter::Info,
+        log::LevelFilter::Info,
     );
 
     log::debug!("XHCI PCI CONFIG: {:?}", pci_config);
 
     let address = unsafe { pcid_handle.map_bar(0) }.ptr.as_ptr() as usize;
 
-    let (irq_file, interrupt_method) = (None, InterruptMethod::Polling); //get_int_method(&mut pcid_handle);
+    let (irq_file, interrupt_method) = (None, InterruptMethod::Polling); //get_int_method(&mut pcid_handle, address);
                                                                          //TODO: Fix interrupts.
 
-    log::info!("XHCI {}", pci_config.func.display());
+    println!(" + XHCI {}", pci_config.func.display());
 
     let scheme_name = format!("usb.{}", name);
     let socket = Socket::create(scheme_name.clone()).expect("xhcid: failed to create usb scheme");
 
-    daemon.ready();
+    daemon.ready().expect("xhcid: failed to notify parent");
 
     let hci = Arc::new(
-        Xhci::<N>::new(scheme_name, address, interrupt_method, pcid_handle)
+        Xhci::new(scheme_name, address, interrupt_method, pcid_handle)
             .expect("xhcid: failed to allocate device"),
     );
 
@@ -180,17 +222,3 @@ fn daemon_with_context_size<const N: usize>(
         }
     }
 }
-
-fn main() {
-    pcid_interface::pci_daemon(daemon);
-}
-
-fn daemon(daemon: daemon::Daemon, mut pcid_handle: PciFunctionHandle) -> ! {
-    let address = unsafe { pcid_handle.map_bar(0) }.ptr.as_ptr() as usize;
-    let cap = unsafe { &mut *(address as *mut xhci::CapabilityRegs) };
-    if cap.csz() {
-        daemon_with_context_size::<{ xhci::CONTEXT_64 }>(daemon, pcid_handle)
-    } else {
-        daemon_with_context_size::<{ xhci::CONTEXT_32 }>(daemon, pcid_handle)
-    }
-}
diff --git a/drivers/usb/xhcid/src/xhci/capability.rs b/drivers/usb/xhcid/src/xhci/capability.rs
index 2ad4ad1a..cc45611c 100644
--- a/drivers/usb/xhcid/src/xhci/capability.rs
+++ b/drivers/usb/xhcid/src/xhci/capability.rs
@@ -120,10 +120,6 @@ pub struct CapabilityRegs {
 pub const HCC_PARAMS1_AC64_BIT: u32 = 1 << HCC_PARAMS1_AC64_SHIFT;
 /// The shift to use to get the AC64 bit from HCCParams1. See [CapabilityRegs]
 pub const HCC_PARAMS1_AC64_SHIFT: u8 = 0;
-/// The mask to use to get the CSZ bit from HCCPARAMS1. See [CapabilityRegs]
-pub const HCC_PARAMS1_CSZ_BIT: u32 = 1 << HCC_PARAMS1_CSZ_SHIFT;
-/// The shift to use to get the CSZ bit from HCCParams1. See [CapabilityRegs]
-pub const HCC_PARAMS1_CSZ_SHIFT: u8 = 2;
 /// The Mask to use to get the MAXPSASIZE value from HCCParams1. See [CapabilityRegs]
 pub const HCC_PARAMS1_MAXPSASIZE_MASK: u32 = 0xF000; // 15:12
 /// The shift to use to get the MAXPSASIZE value from HCCParams1. See [CapabilityRegs]
@@ -165,11 +161,6 @@ impl CapabilityRegs {
         self.hcc_params1.readf(HCC_PARAMS1_AC64_BIT)
     }
 
-    /// Gets the context size (CSZ) bit from HCCParams1.
-    pub fn csz(&self) -> bool {
-        self.hcc_params1.readf(HCC_PARAMS1_CSZ_BIT)
-    }
-
     /// Gets the LEC bit from HCCParams2.
     pub fn lec(&self) -> bool {
         self.hcc_params2.readf(HCC_PARAMS2_LEC_BIT)
diff --git a/drivers/usb/xhcid/src/xhci/context.rs b/drivers/usb/xhcid/src/xhci/context.rs
index b8f2f45a..497a39da 100644
--- a/drivers/usb/xhcid/src/xhci/context.rs
+++ b/drivers/usb/xhcid/src/xhci/context.rs
@@ -10,25 +10,24 @@ use common::dma::Dma;
 use super::ring::Ring;
 use super::Xhci;
 
-pub const CONTEXT_32: usize = 0;
-pub const CONTEXT_64: usize = 1;
-
-#[repr(C, packed)]
-struct Rsvd64<const N: usize>([[Mmio<u32>; 8]; N]);
-
 #[repr(C, packed)]
-pub struct SlotContext<const N: usize> {
+pub struct SlotContext {
     pub a: Mmio<u32>,
     pub b: Mmio<u32>,
     pub c: Mmio<u32>,
     pub d: Mmio<u32>,
     _rsvd: [Mmio<u32>; 4],
-    _rsvd64: Rsvd64<N>,
 }
 
 pub const SLOT_CONTEXT_STATE_MASK: u32 = 0xF800_0000;
 pub const SLOT_CONTEXT_STATE_SHIFT: u8 = 27;
 
+impl SlotContext {
+    pub fn state(&self) -> u8 {
+        ((self.d.read() & SLOT_CONTEXT_STATE_MASK) >> SLOT_CONTEXT_STATE_SHIFT) as u8
+    }
+}
+
 #[repr(u8)]
 pub enum SlotState {
     EnabledOrDisabled = 0,
@@ -38,34 +37,32 @@ pub enum SlotState {
 }
 
 #[repr(C, packed)]
-pub struct EndpointContext<const N: usize> {
+pub struct EndpointContext {
     pub a: Mmio<u32>,
     pub b: Mmio<u32>,
     pub trl: Mmio<u32>,
     pub trh: Mmio<u32>,
     pub c: Mmio<u32>,
     _rsvd: [Mmio<u32>; 3],
-    _rsvd64: Rsvd64<N>,
 }
 
 pub const ENDPOINT_CONTEXT_STATUS_MASK: u32 = 0x7;
 
 #[repr(C, packed)]
-pub struct DeviceContext<const N: usize> {
-    pub slot: SlotContext<N>,
-    pub endpoints: [EndpointContext<N>; 31],
+pub struct DeviceContext {
+    pub slot: SlotContext,
+    pub endpoints: [EndpointContext; 31],
 }
 
 #[repr(C, packed)]
-pub struct InputContext<const N: usize> {
+pub struct InputContext {
     pub drop_context: Mmio<u32>,
     pub add_context: Mmio<u32>,
     _rsvd: [Mmio<u32>; 5],
     pub control: Mmio<u32>,
-    _rsvd64: Rsvd64<N>,
-    pub device: DeviceContext<N>,
+    pub device: DeviceContext,
 }
-impl<const N: usize> InputContext<N> {
+impl InputContext {
     pub fn dump_control(&self) {
         debug!(
             "INPUT CONTEXT: {} {} [{} {} {} {} {}] {}",
@@ -81,19 +78,19 @@ impl<const N: usize> InputContext<N> {
     }
 }
 
-pub struct DeviceContextList<const N: usize> {
+pub struct DeviceContextList {
     pub dcbaa: Dma<[u64; 256]>,
-    pub contexts: Box<[Dma<DeviceContext<N>>]>,
+    pub contexts: Box<[Dma<DeviceContext>]>,
 }
 
-impl<const N: usize> DeviceContextList<N> {
-    pub fn new(ac64: bool, max_slots: u8) -> Result<Self> {
-        let mut dcbaa = unsafe { Xhci::<N>::alloc_dma_zeroed_raw::<[u64; 256]>(ac64)? };
+impl DeviceContextList {
+    pub fn new(ac64: bool, max_slots: u8) -> Result<DeviceContextList> {
+        let mut dcbaa = unsafe { Xhci::alloc_dma_zeroed_raw::<[u64; 256]>(ac64)? };
         let mut contexts = vec![];
 
         // Create device context buffers for each slot
         for i in 0..max_slots as usize {
-            let context: Dma<DeviceContext<N>> = unsafe { Xhci::<N>::alloc_dma_zeroed_raw(ac64) }?;
+            let context: Dma<DeviceContext> = unsafe { Xhci::alloc_dma_zeroed_raw(ac64) }?;
             dcbaa[i] = context.physical() as u64;
             contexts.push(context);
         }
@@ -137,24 +134,19 @@ pub struct StreamContextArray {
 }
 
 impl StreamContextArray {
-    pub fn new<const N: usize>(ac64: bool, count: usize) -> Result<Self> {
+    pub fn new(ac64: bool, count: usize) -> Result<Self> {
         unsafe {
             Ok(Self {
-                contexts: Xhci::<N>::alloc_dma_zeroed_unsized_raw(ac64, count)?,
+                contexts: Xhci::alloc_dma_zeroed_unsized_raw(ac64, count)?,
                 rings: BTreeMap::new(),
             })
         }
     }
-    pub fn add_ring<const N: usize>(
-        &mut self,
-        ac64: bool,
-        stream_id: u16,
-        link: bool,
-    ) -> Result<()> {
+    pub fn add_ring(&mut self, ac64: bool, stream_id: u16, link: bool) -> Result<()> {
         // NOTE: stream_id 0 is reserved
         assert_ne!(stream_id, 0);
 
-        let ring = Ring::new::<N>(ac64, 16, link)?;
+        let ring = Ring::new(ac64, 16, link)?;
         let pointer = ring.register();
         let sct = StreamContextType::PrimaryRing;
 
@@ -190,9 +182,8 @@ pub struct ScratchpadBufferArray {
     pub pages: Vec<Dma<[u8; PAGE_SIZE]>>,
 }
 impl ScratchpadBufferArray {
-    pub fn new<const N: usize>(ac64: bool, entries: u16) -> Result<Self> {
-        let mut entries =
-            unsafe { Xhci::<N>::alloc_dma_zeroed_unsized_raw(ac64, entries as usize)? };
+    pub fn new(ac64: bool, entries: u16) -> Result<Self> {
+        let mut entries = unsafe { Xhci::alloc_dma_zeroed_unsized_raw(ac64, entries as usize)? };
 
         let pages = entries
             .iter_mut()
@@ -212,17 +203,3 @@ impl ScratchpadBufferArray {
         self.entries.physical()
     }
 }
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use core::mem;
-
-    #[test]
-    fn context_size() {
-        assert_eq!(mem::size_of::<SlotContext<CONTEXT_32>>(), 32);
-        assert_eq!(mem::size_of::<SlotContext<CONTEXT_64>>(), 64);
-        assert_eq!(mem::size_of::<EndpointContext<CONTEXT_32>>(), 32);
-        assert_eq!(mem::size_of::<EndpointContext<CONTEXT_64>>(), 64);
-    }
-}
diff --git a/drivers/usb/xhcid/src/xhci/device_enumerator.rs b/drivers/usb/xhcid/src/xhci/device_enumerator.rs
index a84c2ada..f33f420c 100644
--- a/drivers/usb/xhcid/src/xhci/device_enumerator.rs
+++ b/drivers/usb/xhcid/src/xhci/device_enumerator.rs
@@ -11,13 +11,13 @@ pub struct DeviceEnumerationRequest {
     pub port_id: PortId,
 }
 
-pub struct DeviceEnumerator<const N: usize> {
-    hci: Arc<Xhci<N>>,
+pub struct DeviceEnumerator {
+    hci: Arc<Xhci>,
     request_queue: crossbeam_channel::Receiver<DeviceEnumerationRequest>,
 }
 
-impl<const N: usize> DeviceEnumerator<N> {
-    pub fn new(hci: Arc<Xhci<N>>) -> Self {
+impl DeviceEnumerator {
+    pub fn new(hci: Arc<Xhci>) -> Self {
         let request_queue = hci.device_enumerator_receiver.clone();
         DeviceEnumerator { hci, request_queue }
     }
@@ -35,7 +35,7 @@ impl<const N: usize> DeviceEnumerator<N> {
             let port_id = request.port_id;
             let port_array_index = port_id.root_hub_port_index();
 
-            debug!("Device Enumerator request for port {}", port_id);
+            info!("Device Enumerator request for port {}", port_id);
 
             let (len, flags) = {
                 let ports = self.hci.ports.lock().unwrap();
@@ -54,7 +54,7 @@ impl<const N: usize> DeviceEnumerator<N> {
             };
 
             if flags.contains(PortFlags::CCS) {
-                debug!(
+                info!(
                     "Received Device Connect Port Status Change Event with port flags {:?}",
                     flags
                 );
@@ -78,7 +78,7 @@ impl<const N: usize> DeviceEnumerator<N> {
 
                     //THIS LOCKS THE PORTS. DO NOT LOCK PORTS BEFORE THIS POINT
                     info!("Received a device connect on port {}, but it's not enabled. Resetting the port.", port_id);
-                    let _ = self.hci.reset_port(port_id);
+                    self.hci.reset_port(port_id);
 
                     let mut ports = self.hci.ports.lock().unwrap();
                     let port = &mut ports[port_array_index];
@@ -114,14 +114,14 @@ impl<const N: usize> DeviceEnumerator<N> {
                     }
                     Err(err) => {
                         if err.errno == EAGAIN {
-                            debug!("Received a device connect notification for an already connected device. Ignoring...")
+                            info!("Received a device connect notification for an already connected device. Ignoring...")
                         } else {
                             warn!("processing of device attach request failed! Error: {}", err);
                         }
                     }
                 }
             } else {
-                debug!(
+                info!(
                     "Device Enumerator received Detach request on port {} which is in state {}",
                     port_id,
                     self.hci.get_pls(port_id)
diff --git a/drivers/usb/xhcid/src/xhci/event.rs b/drivers/usb/xhcid/src/xhci/event.rs
index 83af1209..47c370cc 100644
--- a/drivers/usb/xhcid/src/xhci/event.rs
+++ b/drivers/usb/xhcid/src/xhci/event.rs
@@ -23,10 +23,10 @@ pub struct EventRing {
 }
 
 impl EventRing {
-    pub fn new<const N: usize>(ac64: bool) -> Result<EventRing> {
+    pub fn new(ac64: bool) -> Result<EventRing> {
         let mut ring = EventRing {
-            ste: unsafe { Xhci::<N>::alloc_dma_zeroed_unsized_raw(ac64, 1)? },
-            ring: Ring::new::<N>(ac64, 256, false)?,
+            ste: unsafe { Xhci::alloc_dma_zeroed_unsized_raw(ac64, 1)? },
+            ring: Ring::new(ac64, 256, false)?,
         };
 
         ring.ste[0]
diff --git a/drivers/usb/xhcid/src/xhci/irq_reactor.rs b/drivers/usb/xhcid/src/xhci/irq_reactor.rs
index ac492d5b..c5510404 100644
--- a/drivers/usb/xhcid/src/xhci/irq_reactor.rs
+++ b/drivers/usb/xhcid/src/xhci/irq_reactor.rs
@@ -92,8 +92,8 @@ impl StateKind {
     }
 }
 
-pub struct IrqReactor<const N: usize> {
-    hci: Arc<Xhci<N>>,
+pub struct IrqReactor {
+    hci: Arc<Xhci>,
     irq_file: Option<File>,
     irq_receiver: Receiver<NewPendingTrb>,
     device_enumerator_sender: Sender<DeviceEnumerationRequest>,
@@ -104,8 +104,8 @@ pub struct IrqReactor<const N: usize> {
 
 pub type NewPendingTrb = State;
 
-impl<const N: usize> IrqReactor<N> {
-    pub fn new(hci: Arc<Xhci<N>>, irq_file: Option<File>) -> Self {
+impl IrqReactor {
+    pub fn new(hci: Arc<Xhci>, irq_file: Option<File>) -> Self {
         let device_enumerator_sender = hci.device_enumerator_sender.clone();
         let irq_receiver = hci.irq_reactor_receiver.clone();
 
@@ -121,7 +121,7 @@ impl<const N: usize> IrqReactor<N> {
     fn pause(&self) {
         std::thread::sleep(std::time::Duration::from_millis(2));
     }
-    fn run_polling(mut self) -> ! {
+    fn run_polling(mut self) {
         debug!("Running IRQ reactor in polling mode.");
         let hci_clone = Arc::clone(&self.hci);
 
@@ -204,11 +204,11 @@ impl<const N: usize> IrqReactor<N> {
         run.ints[0].iman.writef(1 << 1, true);
     }
 
-    fn run_with_irq_file(mut self) -> ! {
+    fn run_with_irq_file(mut self) {
         debug!("Running IRQ reactor with IRQ file and event queue");
 
         let hci_clone = Arc::clone(&self.hci);
-        let event_queue =
+        let mut event_queue =
             RawEventQueue::new().expect("xhcid irq_reactor: failed to create IRQ event queue");
         let irq_fd = self.irq_file.as_ref().unwrap().as_raw_fd();
         event_queue
@@ -226,8 +226,7 @@ impl<const N: usize> IrqReactor<N> {
         };
 
         trace!("IRQ reactor has grabbed the next index in the event ring.");
-        'trb_loop: loop {
-            let _event = event_queue.next_event().unwrap();
+        for _event in event_queue {
             trace!("IRQ event queue notified");
             let mut buffer = [0u8; 8];
 
@@ -241,7 +240,7 @@ impl<const N: usize> IrqReactor<N> {
             if !self.hci.received_irq() {
                 // continue only when an IRQ to this device was received
                 trace!("no interrupt pending");
-                continue 'trb_loop;
+                break;
             }
 
             self.mask_interrupts();
@@ -266,7 +265,7 @@ impl<const N: usize> IrqReactor<N> {
                     }
                     //hci_clone.event_handler_finished();
                     self.unmask_interrupts();
-                    continue 'trb_loop;
+                    return;
                 } else {
                     count += 1
                 }
@@ -288,7 +287,7 @@ impl<const N: usize> IrqReactor<N> {
                         debug!("The interrupt bit is no longer pending.");
                     }
                     self.unmask_interrupts();
-                    continue 'trb_loop;
+                    return;
                 }
                 self.handle_requests();
 
@@ -310,7 +309,9 @@ impl<const N: usize> IrqReactor<N> {
 
                 event_trb_index = event_ring.ring.next_index();
             }
+            trace!("Exited event loop!");
         }
+        trace!("IRQ Reactor has finished handling the interrupt");
     }
 
     /// Handles device attach/detach events as indicated by a PortStatusChange
@@ -332,16 +333,7 @@ impl<const N: usize> IrqReactor<N> {
                 );
             {
                 let mut ports = self.hci.ports.lock().unwrap();
-                let root_port_index = port_id.root_hub_port_index();
-                if root_port_index >= ports.len() {
-                    warn!(
-                        "Received out of bounds transmit device numeration request on root index {} at port {} [port len was: {}]",
-                        root_port_index, port_id, ports.len()
-                    );
-                    return;
-                }
-
-                let port = &mut ports[root_port_index];
+                let port = &mut ports[port_id.root_hub_port_index()];
                 port.clear_csc();
             }
         } else {
@@ -537,7 +529,7 @@ impl<const N: usize> IrqReactor<N> {
         error!("TODO: grow event ring");
     }
 
-    pub fn run(self) -> ! {
+    pub fn run(mut self) {
         if self.irq_file.is_some() {
             self.run_with_irq_file();
         } else {
@@ -559,7 +551,7 @@ pub struct EventDoorbell {
 }
 
 impl EventDoorbell {
-    pub fn new<const N: usize>(hci: &Xhci<N>, index: usize, data: u32) -> Self {
+    pub fn new(hci: &Xhci, index: usize, data: u32) -> Self {
         Self {
             //TODO: simplify this logic, maybe just use a raw pointer?
             dbs: hci.dbs.clone(),
@@ -625,7 +617,7 @@ impl Future for EventTrbFuture {
     }
 }
 
-impl<const N: usize> Xhci<N> {
+impl Xhci {
     pub fn get_transfer_trb(&self, paddr: u64, id: RingId) -> Option<Trb> {
         self.with_ring(id, |ring| ring.phys_addr_to_entry(self.cap.ac64(), paddr))
             .flatten()
diff --git a/drivers/usb/xhcid/src/xhci/mod.rs b/drivers/usb/xhcid/src/xhci/mod.rs
index 5881b559..3d3798a3 100644
--- a/drivers/usb/xhcid/src/xhci/mod.rs
+++ b/drivers/usb/xhcid/src/xhci/mod.rs
@@ -12,21 +12,23 @@
 use std::collections::BTreeMap;
 use std::convert::TryFrom;
 use std::fs::File;
+use std::ptr::NonNull;
 use std::sync::atomic::AtomicUsize;
-use std::sync::{Arc, Mutex};
+use std::sync::{Arc, Mutex, MutexGuard};
 
 use std::{mem, process, slice, thread};
 use syscall::error::{Error, Result, EBADF, EBADMSG, EIO, ENOENT};
 use syscall::{EAGAIN, PAGE_SIZE};
 
 use chashmap::CHashMap;
-use common::{dma::Dma, io::Io, timeout::Timeout};
+use common::{dma::Dma, io::Io};
 use crossbeam_channel::{Receiver, Sender};
 use log::{debug, error, info, trace, warn};
 use serde::Deserialize;
 
 use crate::usb;
 
+use pcid_interface::msi::{MsixInfo, MsixTableEntry};
 use pcid_interface::PciFunctionHandle;
 
 mod capability;
@@ -43,17 +45,13 @@ mod runtime;
 pub mod scheme;
 mod trb;
 
-pub use self::capability::CapabilityRegs;
-use self::context::{
-    DeviceContextList, InputContext, ScratchpadBufferArray, StreamContextArray,
-    SLOT_CONTEXT_STATE_MASK, SLOT_CONTEXT_STATE_SHIFT,
-};
-pub use self::context::{CONTEXT_32, CONTEXT_64};
+use self::capability::CapabilityRegs;
+use self::context::{DeviceContextList, InputContext, ScratchpadBufferArray, StreamContextArray};
 use self::doorbell::Doorbell;
 use self::event::EventRing;
 use self::extended::{CapabilityId, ExtendedCapabilitiesIter, ProtocolSpeed, SupportedProtoCap};
 use self::irq_reactor::{EventDoorbell, IrqReactor, NewPendingTrb, RingId};
-use self::operational::*;
+use self::operational::OperationalRegs;
 use self::port::Port;
 use self::ring::Ring;
 use self::runtime::RuntimeRegs;
@@ -73,11 +71,28 @@ pub enum InterruptMethod {
     /// Legacy PCI INTx# interrupt pin.
     Intx,
 
-    /// (Extended) Message signaled interrupts.
+    /// Message signaled interrupts.
     Msi,
+
+    /// Extended message signaled interrupts.
+    MsiX(Mutex<MappedMsixRegs>),
+}
+
+pub struct MappedMsixRegs {
+    pub virt_table_base: NonNull<MsixTableEntry>,
+    pub info: MsixInfo,
+}
+impl MappedMsixRegs {
+    pub unsafe fn table_entry_pointer_unchecked(&mut self, k: usize) -> &mut MsixTableEntry {
+        &mut *self.virt_table_base.as_ptr().offset(k as isize)
+    }
+    pub fn table_entry_pointer(&mut self, k: usize) -> &mut MsixTableEntry {
+        assert!(k < self.info.table_size as usize);
+        unsafe { self.table_entry_pointer_unchecked(k) }
+    }
 }
 
-impl<const N: usize> Xhci<N> {
+impl Xhci {
     /// Gets descriptors, before the port state is initiated.
     async fn get_desc_raw<T>(
         &self,
@@ -250,7 +265,7 @@ impl<const N: usize> Xhci<N> {
 }
 
 /// The eXtensible Host Controller Interface (XHCI) data structure
-pub struct Xhci<const N: usize> {
+pub struct Xhci {
     // immutable
     /// The Host Controller Interface Capability Registers. These read-only registers specify the
     /// limits and capabilities of the host controller implementation (See XHCI section 5.3)
@@ -274,7 +289,7 @@ pub struct Xhci<const N: usize> {
     primary_event_ring: Mutex<EventRing>,
 
     // immutable
-    dev_ctx: DeviceContextList<N>,
+    dev_ctx: DeviceContextList,
     scratchpad_buf_arr: Option<ScratchpadBufferArray>,
 
     // used for the extended capabilities, and so far none of them are mutated, and thus no lock.
@@ -282,7 +297,7 @@ pub struct Xhci<const N: usize> {
 
     handles: CHashMap<usize, scheme::Handle>,
     next_handle: AtomicUsize,
-    port_states: CHashMap<PortId, PortState<N>>,
+    port_states: CHashMap<PortId, PortState>,
     drivers: CHashMap<PortId, Vec<process::Child>>,
     scheme_name: String,
 
@@ -301,19 +316,19 @@ pub struct Xhci<const N: usize> {
     device_enumerator_receiver: Receiver<DeviceEnumerationRequest>,
 }
 
-unsafe impl<const N: usize> Send for Xhci<N> {}
-unsafe impl<const N: usize> Sync for Xhci<N> {}
+unsafe impl Send for Xhci {}
+unsafe impl Sync for Xhci {}
 
-struct PortState<const N: usize> {
+struct PortState {
     slot: u8,
     protocol_speed: &'static ProtocolSpeed,
     cfg_idx: Option<u8>,
-    input_context: Mutex<Dma<InputContext<N>>>,
+    input_context: Mutex<Dma<InputContext>>,
     dev_desc: Option<DevDesc>,
     endpoint_states: BTreeMap<u8, EndpointState>,
 }
 
-impl<const N: usize> PortState<N> {
+impl PortState {
     //TODO: fetch using endpoint number instead
     fn get_endp_desc(&self, endp_idx: u8) -> Option<&EndpDesc> {
         let cfg_idx = self.cfg_idx?;
@@ -354,13 +369,13 @@ impl EndpointState {
     }
 }
 
-impl<const N: usize> Xhci<N> {
+impl Xhci {
     pub fn new(
         scheme_name: String,
         address: usize,
         interrupt_method: InterruptMethod,
         pcid_handle: PciFunctionHandle,
-    ) -> Result<Self> {
+    ) -> Result<Xhci> {
         //Locate the capability registers from the mapped PCI Bar
         let cap = unsafe { &mut *(address as *mut CapabilityRegs) };
         debug!("CAP REGS BASE {:X}", address);
@@ -374,42 +389,26 @@ impl<const N: usize> Xhci<N> {
 
         //Reset the XHCI device
         let (max_slots, max_ports) = {
-            {
-                debug!("Waiting for xHC becoming ready.");
-                let timeout = Timeout::from_secs(1);
-                while op.usb_sts.readf(USB_STS_CNR) {
-                    timeout.run().map_err(|()| {
-                        log::error!("timeout on USB_STS_CNR");
-                        Error::new(EIO)
-                    })?;
-                }
+            debug!("Waiting for xHC becoming ready.");
+            // Wait until controller is ready
+            while op.usb_sts.readf(1 << 11) {
+                trace!("Waiting for the xHC to be ready.");
             }
 
             debug!("Stopping the xHC");
             // Set run/stop to 0
-            op.usb_cmd.writef(USB_CMD_RS, false);
+            op.usb_cmd.writef(1, false);
 
-            {
-                debug!("Waiting for the xHC to stop.");
-                let timeout = Timeout::from_secs(1);
-                while !op.usb_sts.readf(USB_STS_HCH) {
-                    timeout.run().map_err(|()| {
-                        log::error!("timeout on USB_STS_HCH");
-                        Error::new(EIO)
-                    })?;
-                }
+            debug!("Waiting for the xHC to stop.");
+            // Wait until controller not running
+            while !op.usb_sts.readf(1) {
+                trace!("Waiting for the xHC to stop.");
             }
 
-            {
-                debug!("Resetting the xHC.");
-                op.usb_cmd.writef(USB_CMD_HCRST, true);
-                let timeout = Timeout::from_secs(1);
-                while op.usb_cmd.readf(USB_CMD_HCRST) {
-                    timeout.run().map_err(|()| {
-                        log::error!("timeout on USB_CMD_HCRST");
-                        Error::new(EIO)
-                    })?;
-                }
+            debug!("Resetting the xHC.");
+            op.usb_cmd.writef(1 << 1, true);
+            while op.usb_sts.readf(1 << 1) {
+                trace!("Waiting for the xHC to reset.");
             }
 
             debug!("Reading max slots.");
@@ -439,7 +438,7 @@ impl<const N: usize> Xhci<N> {
         // Create the command ring with 4096 / 16 (TRB size) entries, so that it uses all of the
         // DMA allocation (which is at least a 4k page).
         let entries_per_page = PAGE_SIZE / mem::size_of::<Trb>();
-        let cmd = Ring::new::<N>(cap.ac64(), entries_per_page, true)?;
+        let cmd = Ring::new(cap.ac64(), entries_per_page, true)?;
 
         let (irq_reactor_sender, irq_reactor_receiver) = crossbeam_channel::unbounded();
 
@@ -459,7 +458,7 @@ impl<const N: usize> Xhci<N> {
             scratchpad_buf_arr: None, // initialized in init()
 
             cmd: Mutex::new(cmd),
-            primary_event_ring: Mutex::new(EventRing::new::<N>(cap.ac64())?),
+            primary_event_ring: Mutex::new(EventRing::new(cap.ac64())?),
             handles: CHashMap::new(),
             next_handle: AtomicUsize::new(0),
             port_states: CHashMap::new(),
@@ -485,23 +484,13 @@ impl<const N: usize> Xhci<N> {
     pub fn init(&mut self, max_slots: u8) -> Result<()> {
         // Set run/stop to 0
         debug!("Stopping xHC.");
-        self.op.get_mut().unwrap().usb_cmd.writef(USB_CMD_RS, false);
+        self.op.get_mut().unwrap().usb_cmd.writef(1, false);
 
         // Warm reset
-        {
-            debug!("Reset xHC");
-            let timeout = Timeout::from_secs(1);
-            self.op
-                .get_mut()
-                .unwrap()
-                .usb_cmd
-                .writef(USB_CMD_HCRST, true);
-            while self.op.get_mut().unwrap().usb_cmd.readf(USB_CMD_HCRST) {
-                timeout.run().map_err(|()| {
-                    log::error!("timeout on USB_CMD_HCRST");
-                    Error::new(EIO)
-                })?;
-            }
+        debug!("Reset xHC");
+        self.op.get_mut().unwrap().usb_cmd.writef(1 << 1, true);
+        while self.op.get_mut().unwrap().usb_cmd.readf(1 << 1) {
+            thread::yield_now();
         }
 
         // Set enabled slots
@@ -561,28 +550,19 @@ impl<const N: usize> Xhci<N> {
             debug!("Enabling Primary Interrupter.");
             int.iman.writef(1 << 1 | 1, true);
         }
-        self.op
-            .get_mut()
-            .unwrap()
-            .usb_cmd
-            .writef(USB_CMD_INTE, true);
+        self.op.get_mut().unwrap().usb_cmd.writef(1 << 2, true);
 
         // Setup the scratchpad buffers that are required for the xHC to function.
         self.setup_scratchpads()?;
 
         // Set run/stop to 1
         debug!("Starting xHC.");
-        self.op.get_mut().unwrap().usb_cmd.writef(USB_CMD_RS, true);
+        self.op.get_mut().unwrap().usb_cmd.writef(1, true);
 
-        {
-            debug!("Waiting for start request to complete.");
-            let timeout = Timeout::from_secs(1);
-            while self.op.get_mut().unwrap().usb_sts.readf(USB_STS_HCH) {
-                timeout.run().map_err(|()| {
-                    log::error!("timeout on USB_STS_HCH");
-                    Error::new(EIO)
-                })?;
-            }
+        // Wait until controller is running
+        debug!("Waiting for start request to complete.");
+        while self.op.get_mut().unwrap().usb_sts.readf(1) {
+            trace!("Waiting for XHCI to report running status.");
         }
 
         // Ring command doorbell
@@ -681,7 +661,7 @@ impl<const N: usize> Xhci<N> {
             };
         }
     }
-    pub fn reset_port(&self, port_id: PortId) -> Result<()> {
+    pub fn reset_port(&self, port_id: PortId) {
         debug!("XHCI Port {} reset", port_id);
 
         //TODO handle the second unwrap
@@ -691,22 +671,20 @@ impl<const N: usize> Xhci<N> {
 
         debug!("Port {} Link State: {}", port_id, port.state());
 
-        {
-            port.set_pr();
-            debug!(
-                "Flags after setting port {} reset: {:?}",
-                port_id,
-                port.flags()
-            );
-            let timeout = Timeout::from_secs(1);
-            while !port.flags().contains(port::PortFlags::PRC) {
-                timeout.run().map_err(|()| {
-                    log::error!("timeout on port {} PRC", port_id);
-                    Error::new(EIO)
-                })?;
+        port.set_pr();
+        debug!(
+            "Flags after setting port {} reset: {:?}",
+            port_id,
+            port.flags()
+        );
+        while !port.flags().contains(port::PortFlags::PRC) {
+            debug!("port {} reset loop ran at least once!", port_id);
+            if instant.elapsed().as_secs() >= 1 {
+                warn!("timeout");
+                break;
             }
+            std::thread::yield_now();
         }
-        Ok(())
     }
 
     pub fn setup_scratchpads(&mut self) -> Result<()> {
@@ -715,7 +693,7 @@ impl<const N: usize> Xhci<N> {
         if buf_count == 0 {
             return Ok(());
         }
-        let scratchpad_buf_arr = ScratchpadBufferArray::new::<N>(self.cap.ac64(), buf_count)?;
+        let scratchpad_buf_arr = ScratchpadBufferArray::new(self.cap.ac64(), buf_count)?;
         self.dev_ctx.dcbaa[0] = scratchpad_buf_arr.register() as u64;
         debug!(
             "Setting up {} scratchpads, at {:#0x}",
@@ -774,8 +752,7 @@ impl<const N: usize> Xhci<N> {
     }
 
     pub fn slot_state(&self, slot: usize) -> u8 {
-        ((self.dev_ctx.contexts[slot].slot.d.read() & SLOT_CONTEXT_STATE_MASK)
-            >> SLOT_CONTEXT_STATE_SHIFT) as u8
+        self.dev_ctx.contexts[slot].slot.state()
     }
     pub unsafe fn alloc_dma_zeroed_raw<T>(_ac64: bool) -> Result<Dma<T>> {
         // TODO: ac64
@@ -794,7 +771,7 @@ impl<const N: usize> Xhci<N> {
 
     pub async fn attach_device(&self, port_id: PortId) -> syscall::Result<()> {
         if self.port_states.contains_key(&port_id) {
-            debug!("Already contains port {}", port_id);
+            println!("Already contains port {}", port_id);
             return Err(syscall::Error::new(EAGAIN));
         }
 
@@ -827,18 +804,18 @@ impl<const N: usize> Xhci<N> {
                 }
             };
 
-            debug!("Enabled port {}, which the xHC mapped to {}", port_id, slot);
+            info!("Enabled port {}, which the xHC mapped to {}", port_id, slot);
 
             //TODO: get correct speed for child devices
             let protocol_speed = self
                 .lookup_psiv(port_id, speed)
                 .expect("Failed to retrieve speed ID");
 
-            let mut input = unsafe { self.alloc_dma_zeroed::<InputContext<N>>()? };
+            let mut input = unsafe { self.alloc_dma_zeroed::<InputContext>()? };
 
             info!("Attempting to address the device");
             let mut ring = match self
-                .address_device(&mut input, port_id, slot_ty, slot, protocol_speed, speed)
+                .address_device(&mut input, port_id, slot_ty, slot, protocol_speed)
                 .await
             {
                 Ok(device_ring) => device_ring,
@@ -924,7 +901,7 @@ impl<const N: usize> Xhci<N> {
                         match child.try_wait() {
                             Ok(status_opt) => match status_opt {
                                 Some(status) => {
-                                    debug!(
+                                    info!(
                                         "driver process {} for port {} exited with status {}",
                                         child.id(),
                                         port_id,
@@ -933,7 +910,7 @@ impl<const N: usize> Xhci<N> {
                                 }
                                 None => {
                                     //TODO: kill harder
-                                    warn!(
+                                    info!(
                                         "driver process {} for port {} still running",
                                         child.id(),
                                         port_id
@@ -941,7 +918,7 @@ impl<const N: usize> Xhci<N> {
                                 }
                             },
                             Err(err) => {
-                                warn!(
+                                info!(
                                     "failed to wait for the driver process {} for port {}: {}",
                                     child.id(),
                                     port_id,
@@ -963,16 +940,16 @@ impl<const N: usize> Xhci<N> {
         }
 
         if let Some(state) = self.port_states.remove(&port_id) {
-            debug!("disabling port slot {} for port {}", state.slot, port_id);
+            info!("disabling port slot {} for port {}", state.slot, port_id);
             let result = self.disable_port_slot(state.slot).await;
-            debug!(
+            info!(
                 "disabled port slot {} for port {} with result: {:?}",
                 state.slot, port_id, result
             );
 
             result
         } else {
-            debug!(
+            warn!(
                 "Attempted to detach from port {}, which wasn't previously attached.",
                 port_id
             );
@@ -982,7 +959,7 @@ impl<const N: usize> Xhci<N> {
 
     pub async fn update_max_packet_size(
         &self,
-        input_context: &mut Dma<InputContext<N>>,
+        input_context: &mut Dma<InputContext>,
         slot_id: u8,
         dev_desc: usb::DeviceDescriptor8Byte,
     ) -> Result<()> {
@@ -993,10 +970,11 @@ impl<const N: usize> Xhci<N> {
             // For later USB versions, packet_size is the shift
             1u32 << dev_desc.packet_size
         };
-        let mut b = input_context.device.endpoints[0].b.read();
+        let endp_ctx = &mut input_context.device.endpoints[0];
+        let mut b = endp_ctx.b.read();
         b &= 0x0000_FFFF;
         b |= (new_max_packet_size) << 16;
-        input_context.device.endpoints[0].b.write(b);
+        endp_ctx.b.write(b);
 
         let (event_trb, command_trb) = self
             .execute_command(|trb, cycle| {
@@ -1012,7 +990,7 @@ impl<const N: usize> Xhci<N> {
 
     pub async fn update_default_control_pipe(
         &self,
-        input_context: &mut Dma<InputContext<N>>,
+        input_context: &mut Dma<InputContext>,
         slot_id: u8,
         dev_desc: &DevDesc,
     ) -> Result<()> {
@@ -1027,10 +1005,11 @@ impl<const N: usize> Xhci<N> {
             // For later USB versions, packet_size is the shift
             1u32 << dev_desc.packet_size
         };
-        let mut b = input_context.device.endpoints[0].b.read();
+        let endp_ctx = &mut input_context.device.endpoints[0];
+        let mut b = endp_ctx.b.read();
         b &= 0x0000_FFFF;
         b |= (new_max_packet_size) << 16;
-        input_context.device.endpoints[0].b.write(b);
+        endp_ctx.b.write(b);
 
         let (event_trb, command_trb) = self
             .execute_command(|trb, cycle| {
@@ -1047,12 +1026,11 @@ impl<const N: usize> Xhci<N> {
 
     pub async fn address_device(
         &self,
-        input_context: &mut Dma<InputContext<N>>,
+        input_context: &mut Dma<InputContext>,
         port: PortId,
         slot_ty: u8,
         slot: u8,
         protocol_speed: &ProtocolSpeed,
-        speed: u8,
     ) -> Result<Ring> {
         // Collect MTT, parent port number, parent slot ID
         let mut mtt = false;
@@ -1084,19 +1062,20 @@ impl<const N: usize> Xhci<N> {
             }
         }
 
-        let mut ring = Ring::new::<N>(self.cap.ac64(), 16, true)?;
+        let mut ring = Ring::new(self.cap.ac64(), 16, true)?;
 
         {
             input_context.add_context.write(1 << 1 | 1); // Enable the slot (zeroth bit) and the control endpoint (first bit).
 
+            let slot_ctx = &mut input_context.device.slot;
+
             let route_string = port.route_string;
             let context_entries = 1u8;
             let hub = false;
 
             assert_eq!(route_string & 0x000F_FFFF, route_string);
-            input_context.device.slot.a.write(
+            slot_ctx.a.write(
                 route_string
-                    | (u32::from(speed) << 20)
                     | (u32::from(mtt) << 25)
                     | (u32::from(hub) << 26)
                     | (u32::from(context_entries) << 27),
@@ -1105,7 +1084,7 @@ impl<const N: usize> Xhci<N> {
             let max_exit_latency = 0u16;
             let root_hub_port_num = port.root_hub_port_num;
             let number_of_ports = 0u8;
-            input_context.device.slot.b.write(
+            slot_ctx.b.write(
                 u32::from(max_exit_latency)
                     | (u32::from(root_hub_port_num) << 16)
                     | (u32::from(number_of_ports) << 24),
@@ -1116,28 +1095,33 @@ impl<const N: usize> Xhci<N> {
             let interrupter = 0u8;
 
             assert_eq!(ttt & 0b11, ttt);
-            input_context.device.slot.c.write(
+            slot_ctx.c.write(
                 u32::from(parent_hub_slot_id)
                     | (u32::from(parent_port_num) << 8)
                     | (u32::from(ttt) << 16)
                     | (u32::from(interrupter) << 22),
             );
 
+            let endp_ctx = &mut input_context.device.endpoints[0];
+
             let max_error_count = 3u8; // recommended value according to the XHCI spec
             let ep_ty = 4u8; // control endpoint, bidirectional
-            let max_packet_size: u32 =
-                if protocol_speed.is_lowspeed() || protocol_speed.is_fullspeed() {
-                    8
-                } else if protocol_speed.is_highspeed() {
-                    64
-                } else {
-                    512
-                };
+            let max_packet_size: u32 = if protocol_speed.is_lowspeed() {
+                8 // only valid value
+            } else if protocol_speed.is_fullspeed() {
+                64 // valid values are 8, 16, 32, 64
+            } else if protocol_speed.is_highspeed() {
+                64 // only valid value
+            } else if protocol_speed.is_superspeed_gen_x() {
+                512 // only valid value
+            } else {
+                unreachable!()
+            };
             let host_initiate_disable = false; // only applies to streams
             let max_burst_size = 0u8; // TODO
 
             assert_eq!(max_error_count & 0b11, max_error_count);
-            input_context.device.endpoints[0].b.write(
+            endp_ctx.b.write(
                 (u32::from(max_error_count) << 1)
                     | (u32::from(ep_ty) << 3)
                     | (u32::from(host_initiate_disable) << 7)
@@ -1145,20 +1129,9 @@ impl<const N: usize> Xhci<N> {
                     | (u32::from(max_packet_size) << 16),
             );
 
-            let dequeue_cycle_state = true;
             let tr = ring.register();
-            input_context.device.endpoints[0]
-                .trh
-                .write((tr >> 32) as u32);
-            input_context.device.endpoints[0]
-                .trl
-                .write((tr as u32) | u32::from(dequeue_cycle_state));
-
-            // The default control pipe can always use 8 bytes
-            let avg_trb_len = 8u8;
-            input_context.device.endpoints[0]
-                .c
-                .write(u32::from(avg_trb_len));
+            endp_ctx.trh.write((tr >> 32) as u32);
+            endp_ctx.trl.write(tr as u32);
         }
 
         let input_context_physical = input_context.physical();
@@ -1184,8 +1157,32 @@ impl<const N: usize> Xhci<N> {
         Ok(ring)
     }
 
-    fn uses_msi_interrupts(&self) -> bool {
-        matches!(self.interrupt_method, InterruptMethod::Msi)
+    pub fn uses_msi(&self) -> bool {
+        if let InterruptMethod::Msi = self.interrupt_method {
+            true
+        } else {
+            false
+        }
+    }
+    pub fn uses_msix(&self) -> bool {
+        if let InterruptMethod::MsiX(_) = self.interrupt_method {
+            true
+        } else {
+            false
+        }
+    }
+    // TODO: Perhaps use an rwlock?
+    pub fn msix_info(&self) -> Option<MutexGuard<'_, MappedMsixRegs>> {
+        match self.interrupt_method {
+            InterruptMethod::MsiX(ref info) => Some(info.lock().unwrap()),
+            _ => None,
+        }
+    }
+    pub fn msix_info_mut(&self) -> Option<MutexGuard<'_, MappedMsixRegs>> {
+        match self.interrupt_method {
+            InterruptMethod::MsiX(ref info) => Some(info.lock().unwrap()),
+            _ => None,
+        }
     }
 
     /// Checks whether an IRQ has been received from *this* device, in case of an interrupt. Always
@@ -1193,20 +1190,20 @@ impl<const N: usize> Xhci<N> {
     pub fn received_irq(&self) -> bool {
         let mut runtime_regs = self.run.lock().unwrap();
 
-        if self.uses_msi_interrupts() {
+        if self.uses_msi() || self.uses_msix() {
             // Since using MSI and MSI-X implies having no IRQ sharing whatsoever, the IP bit
             // doesn't have to be touched.
             trace!(
                 "Successfully received MSI/MSI-X interrupt, IP={}, EHB={}",
                 runtime_regs.ints[0].iman.readf(1),
-                runtime_regs.ints[0].erdp_low.readf(1 << 3)
+                runtime_regs.ints[0].erdp_low.readf(3)
             );
             true
         } else if runtime_regs.ints[0].iman.readf(1) {
             trace!(
                 "Successfully received INTx# interrupt, IP={}, EHB={}",
                 runtime_regs.ints[0].iman.readf(1),
-                runtime_regs.ints[0].erdp_low.readf(1 << 3)
+                runtime_regs.ints[0].erdp_low.readf(3)
             );
             // If MSI and/or MSI-X are not used, the interrupt might have to be shared, and thus there is
             // a special register to specify whether the IRQ actually came from the xHC.
@@ -1437,7 +1434,7 @@ impl<const N: usize> Xhci<N> {
             .find(|speed| speed.psiv() == psiv)
     }
 }
-pub fn start_irq_reactor<const N: usize>(hci: &Arc<Xhci<N>>, irq_file: Option<File>) {
+pub fn start_irq_reactor(hci: &Arc<Xhci>, irq_file: Option<File>) {
     let hci_clone = Arc::clone(&hci);
 
     debug!("About to start IRQ reactor");
@@ -1448,7 +1445,7 @@ pub fn start_irq_reactor<const N: usize>(hci: &Arc<Xhci<N>>, irq_file: Option<Fi
     }));
 }
 
-pub fn start_device_enumerator<const N: usize>(hci: &Arc<Xhci<N>>) {
+pub fn start_device_enumerator(hci: &Arc<Xhci>) {
     let hci_clone = Arc::clone(&hci);
 
     debug!("About to start Device Enumerator");
diff --git a/drivers/usb/xhcid/src/xhci/operational.rs b/drivers/usb/xhcid/src/xhci/operational.rs
index 12be4772..6562a487 100644
--- a/drivers/usb/xhcid/src/xhci/operational.rs
+++ b/drivers/usb/xhcid/src/xhci/operational.rs
@@ -76,18 +76,6 @@ pub struct OperationalRegs {
     // The standard has 400-13FFh has a Port Register Set here (likely defined in port.rs).
 }
 
-// Run/stop
-pub const USB_CMD_RS: u32 = 1 << 0;
-/// Host controller reset
-pub const USB_CMD_HCRST: u32 = 1 << 1;
-// Interrupter enable
-pub const USB_CMD_INTE: u32 = 1 << 2;
-
-/// Host controller halted
-pub const USB_STS_HCH: u32 = 1 << 0;
-/// Host controller not ready
-pub const USB_STS_CNR: u32 = 1 << 11;
-
 /// The mask to get the CIE bit from the Config register. See [OperationalRegs]
 pub const OP_CONFIG_CIE_BIT: u32 = 1 << 9;
 
diff --git a/drivers/usb/xhcid/src/xhci/ring.rs b/drivers/usb/xhcid/src/xhci/ring.rs
index 8e187ebe..e0e76d52 100644
--- a/drivers/usb/xhcid/src/xhci/ring.rs
+++ b/drivers/usb/xhcid/src/xhci/ring.rs
@@ -15,10 +15,10 @@ pub struct Ring {
 }
 
 impl Ring {
-    pub fn new<const N: usize>(ac64: bool, length: usize, link: bool) -> Result<Ring> {
+    pub fn new(ac64: bool, length: usize, link: bool) -> Result<Ring> {
         Ok(Ring {
             link,
-            trbs: unsafe { Xhci::<N>::alloc_dma_zeroed_unsized_raw(ac64, length)? },
+            trbs: unsafe { Xhci::alloc_dma_zeroed_unsized_raw(ac64, length)? },
             i: 0,
             cycle: link,
         })
diff --git a/drivers/usb/xhcid/src/xhci/scheme.rs b/drivers/usb/xhcid/src/xhci/scheme.rs
index 1b92fa51..12d77d39 100644
--- a/drivers/usb/xhcid/src/xhci/scheme.rs
+++ b/drivers/usb/xhcid/src/xhci/scheme.rs
@@ -40,10 +40,7 @@ use syscall::{
 use super::{port, usb};
 use super::{EndpointState, PortId, Xhci};
 
-use super::context::{
-    SlotState, StreamContextArray, StreamContextType, CONTEXT_32, CONTEXT_64,
-    SLOT_CONTEXT_STATE_MASK, SLOT_CONTEXT_STATE_SHIFT,
-};
+use super::context::{SlotState, StreamContextArray, StreamContextType};
 use super::extended::ProtocolSpeed;
 use super::irq_reactor::{EventDoorbell, RingId};
 use super::ring::Ring;
@@ -546,7 +543,7 @@ impl AnyDescriptor {
     }
 }
 
-impl<const N: usize> Xhci<N> {
+impl Xhci {
     async fn new_if_desc(
         &self,
         port_id: PortId,
@@ -930,13 +927,13 @@ impl<const N: usize> Xhci<N> {
     fn port_state(
         &self,
         port: PortId,
-    ) -> Result<chashmap::ReadGuard<'_, PortId, super::PortState<N>>> {
+    ) -> Result<chashmap::ReadGuard<'_, PortId, super::PortState>> {
         self.port_states.get(&port).ok_or(Error::new(EBADF))
     }
     fn port_state_mut(
         &self,
         port: PortId,
-    ) -> Result<chashmap::WriteGuard<'_, PortId, super::PortState<N>>> {
+    ) -> Result<chashmap::WriteGuard<'_, PortId, super::PortState>> {
         self.port_states.get_mut(&port).ok_or(Error::new(EBADF))
     }
 
@@ -1106,10 +1103,10 @@ impl<const N: usize> Xhci<N> {
 
             let ring_ptr = if usb_log_max_streams.is_some() {
                 let mut array =
-                    StreamContextArray::new::<N>(self.cap.ac64(), 1 << (primary_streams + 1))?;
+                    StreamContextArray::new(self.cap.ac64(), 1 << (primary_streams + 1))?;
 
                 // TODO: Use as many stream rings as needed.
-                array.add_ring::<N>(self.cap.ac64(), 1, true)?;
+                array.add_ring(self.cap.ac64(), 1, true)?;
                 let array_ptr = array.register();
 
                 assert_eq!(
@@ -1127,7 +1124,7 @@ impl<const N: usize> Xhci<N> {
 
                 array_ptr
             } else {
-                let ring = Ring::new::<N>(self.cap.ac64(), 16, true)?;
+                let ring = Ring::new(self.cap.ac64(), 16, true)?;
                 let ring_ptr = ring.register();
 
                 assert_eq!(
@@ -1149,15 +1146,23 @@ impl<const N: usize> Xhci<N> {
             let mut input_context = port_state.input_context.lock().unwrap();
             input_context.add_context.writef(1 << endp_num_xhc, true);
 
-            let endp_i = endp_num_xhc as usize - 1;
-            input_context.device.endpoints[endp_i].a.write(
+            let endp_ctx = input_context
+                .device
+                .endpoints
+                .get_mut(endp_num_xhc as usize - 1)
+                .ok_or_else(|| {
+                    warn!("failed to find endpoint {}", endp_num_xhc - 1);
+                    Error::new(EIO)
+                })?;
+
+            endp_ctx.a.write(
                 u32::from(mult) << 8
                     | u32::from(primary_streams) << 10
                     | u32::from(linear_stream_array) << 15
                     | u32::from(interval) << 16
                     | u32::from(max_esit_payload_hi) << 24,
             );
-            input_context.device.endpoints[endp_i].b.write(
+            endp_ctx.b.write(
                 max_error_count << 1
                     | u32::from(ep_ty) << 3
                     | u32::from(host_initiate_disable) << 7
@@ -1165,14 +1170,10 @@ impl<const N: usize> Xhci<N> {
                     | u32::from(max_packet_size) << 16,
             );
 
-            input_context.device.endpoints[endp_i]
-                .trl
-                .write(ring_ptr as u32);
-            input_context.device.endpoints[endp_i]
-                .trh
-                .write((ring_ptr >> 32) as u32);
+            endp_ctx.trl.write(ring_ptr as u32);
+            endp_ctx.trh.write((ring_ptr >> 32) as u32);
 
-            input_context.device.endpoints[endp_i]
+            endp_ctx
                 .c
                 .write(u32::from(avg_trb_len) | (u32::from(max_esit_payload_lo) << 16));
 
@@ -2098,7 +2099,7 @@ impl<const N: usize> Xhci<N> {
     }
 }
 
-impl<const N: usize> SchemeSync for &Xhci<N> {
+impl SchemeSync for &Xhci {
     fn open(&mut self, path_str: &str, flags: usize, ctx: &CallerCtx) -> Result<OpenResult> {
         if ctx.uid != 0 {
             return Err(Error::new(EACCES));
@@ -2236,13 +2237,13 @@ impl<const N: usize> SchemeSync for &Xhci<N> {
             },
             &mut Handle::PortState(port_num) => {
                 let ps = self.port_states.get(&port_num).ok_or(Error::new(EBADF))?;
-                let ctx = self
+                let state = self
                     .dev_ctx
                     .contexts
                     .get(ps.slot as usize)
-                    .ok_or(Error::new(EBADF))?;
-                let state = ((ctx.slot.d.read() & SLOT_CONTEXT_STATE_MASK)
-                    >> SLOT_CONTEXT_STATE_SHIFT) as u8;
+                    .ok_or(Error::new(EBADF))?
+                    .slot
+                    .state();
 
                 let string = match state {
                     0 => Some(PortState::EnabledOrDisabled),
@@ -2256,7 +2257,7 @@ impl<const N: usize> SchemeSync for &Xhci<N> {
                 .unwrap_or("unknown")
                 .as_bytes();
 
-                Ok(Xhci::<N>::write_dyn_string(string, buf, offset))
+                Ok(Xhci::write_dyn_string(string, buf, offset))
             }
             &mut Handle::PortReq(port_num, ref mut st) => {
                 let state = std::mem::replace(st, PortReqState::Tmp);
@@ -2315,7 +2316,7 @@ impl<const N: usize> SchemeSync for &Xhci<N> {
         }
     }
 }
-impl<const N: usize> Xhci<N> {
+impl Xhci {
     pub fn on_close(&self, fd: usize) {
         self.handles.remove(&fd);
     }
@@ -2350,7 +2351,9 @@ impl<const N: usize> Xhci<N> {
             .contexts
             .get(slot as usize)
             .ok_or(Error::new(EBADFD))?
-            .endpoints[endp_num_xhc as usize - 1]
+            .endpoints
+            .get(endp_num_xhc as usize - 1)
+            .ok_or(Error::new(EBADFD))?
             .a
             .read()
             & super::context::ENDPOINT_CONTEXT_STATUS_MASK;
